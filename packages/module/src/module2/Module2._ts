/* eslint-disable @typescript-eslint/interface-name-prefix */
import { Logger, ILogger } from '@lskjs/log2';
import get from 'lodash/get';
import assignProps from '@lskjs/utils/assignProps';
import arrayToObject from '@lskjs/utils/arrayToObject';
import asyncMapValues from '@lskjs/utils/asyncMapValues';
import createAsyncModule from './utils/createAsyncModule';
// @ts-ignore
import Err from '@lskjs/utils/Err';
import createEventEmitter from './createEventEmitter';
import { IModuleConstructor, IModulePropsArray, IEventEmitter, IModule, IApp, IModuleKeyValue } from './types';

// abstract
abstract class Module2 implements IModule {
  name: string;
  _module?: boolean | string;
  app?: IApp;
  parent?: IModule;
  ee?: IEventEmitter;
  log: ILogger;
  debug?: boolean;
  config: {
    log?: any;
    [key: string]: any;
  };

  private __createdAt: Date;
  private __initAt: Date;
  private __runAt: Date;
  private __availableModules?: { [name: string]: IAsyncModuleArgs }
  private __initedModules?: { [name: string]: IModuleArgs };

  constructor(...props: IModulePropsArray) {
    assignProps(this, ...props);
  }

  assignProps(...props: IModulePropsArray): void {
    assignProps(this, ...props);
  }

  static async create<T extends IModule>(this: IModuleConstructor<T>, ...props: IModulePropsArray): Promise<T> {
    const instance = new this();
    instance.assignProps(...props);
    instance.__createdAt = new Date();
    await instance.init();
    return instance;
  }

  static async createAndRun<T extends IModule>(this: IModuleConstructor<T>, ...props: IModulePropsArray): Promise<T> {
    const instance = await this.create(...props);
    await instance.run();
    return instance;
  }

  getModules(): { [name: string]: IAsyncModuleArgs } {
    return {};
  }

  private __getModules(): { [name: string]: IAsyncModuleArgs } {
    return {
      ...(await this.getModules()),
      ...(this.modules || {}),
    };
  }

  async module(nameOrNames: string | string[], { run: isRun = false } = {}): IModule | IModuleKeyValue {
    if (!this.__initAt) throw '!inited';
    if (Array.isArray(nameOrNames)) return asyncMapValues(arrayToObject(nameOrNames), (n) => this.module(n));
    const name = nameOrNames;
    if (this.__initedModules[name]) return this.__initedModules[name];
    if (!this.__availableModules || !this.__availableModules[name]) throw `!modules.${name}`;
    try {
      const instance = await createAsyncModule(this.__availableModules[name]);
      if (isRun) await instance.run();
      this.__initedModules[name] = instance;
      return instance;
    } catch (err) {
      this.log.error(`module(${name})`, err);
      throw err;
    }
  }

  createLogger(): ILogger {
    const logProps = get(this, 'config.log', {});
    return new Logger({ ...logProps, name: this.name });
  }

  createEventEmitter(): IEventEmitter {
    return createEventEmitter() as IEventEmitter;
  }

  on(event: string, callback: (event: string, ...args: any[]) => void): void {
    if (!this.ee) this.ee = this.createEventEmitter();
    this.ee.on(event, callback);
  }

  emit(event: string, ...args: any[]): void {
    if (!this.ee) this.ee = this.createEventEmitter();
    this.ee.emit(event, ...args);
  }

  async init(): Promise<void> {
    if (!this.__createdAt) {
      throw new Err('INVALID_NEW_MODULE', 'use Module.create(props) instead new Module(props)');
    }
    if (this.__initAt) return;
    this.__initAt = new Date();
    this.name = this.constructor.name;
    if (!this.log) this.log = this.createLogger();
    if (this.debug && this.log) this.log.trace('init');
    await this.__initModules();
  }

  private async __initModules(): Promise<void> {
    this.__availableModules = await this.__getModules();
    if (this.debug && this.log) this.log.debug('availableModules', Object.keys(this.__availableModules));
    // await this.initModules();
  }
  // async initModules(): Promise<void> {}

  private async __runModules(): Promise<void> {
    await asyncMapValues(this.__initedModules, (m) => m.run());
  }

  async run(): Promise<void> {
    if (this.__runAt) return;
    if (!this.__initAt) await this.init();
    this.__runAt = new Date();
    if (this.debug && this.log) this.log.trace('run');
    await this.__runModules();
  }

  async stop(): Promise<void> {
    //
  }
}

export default Module2;
